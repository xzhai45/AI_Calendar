#     print("ðŸ§µ simulate_llm_generation started")

#     import os
#     import time
#     from typing import List
#     from pydantic import BaseModel
#     from openai import OpenAI
#     from django.contrib.sessions.backends.db import SessionStore
#     import openai, os, json, time
#     from datetime import datetime

#     # Load API key from .env
#     api_key = os.getenv("OPENAI_API_KEY")
#     client = OpenAI(api_key=api_key)
#     current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

#     # Define schema
#     class CalendarEvent(BaseModel):
#         title: str
#         start: str  # ISO 8601 datetime
#         end: str
#         location: str
#         description: str

#     class EventWrapper(BaseModel):
#         events: List[CalendarEvent]

#     # Prepare LLM messages
#     messages = [
#         {
#             "role": "system",
#             "content": "You are a helpful assistant that extracts calendar events from user input."
#         },
#         {
#             "role": "user",
#             "content": f"""

#             Today's date and time is: {current_time}

# Extract all calendar events and return only a JSON list of objects that follow this schema:
# - title: str
# - start: ISO8601 datetime string
# - end: ISO8601 datetime string
# - location: str
# - description: str

# Do NOT return markdown or explanation. Only return valid JSON in the `events` field of an object.
# start and end should be in ISO 8601 format. If no events are found, return an empty list.
# start time should always be before end time. not equal to or after.
# If the user provided a file, use the text from the file to help extract events.
# If the user provided a query, use that to help extract events.
# If the user provided both, use both to extract events.


# Query:
# {query}

# Extracted file text (if any):
# {extracted_text[:800]}
# """
#         }
#     ]

#     try:
#         # Call OpenAI with structured schema
#         completion = client.beta.chat.completions.parse(
#             model="gpt-4o-2024-08-06",
#             messages=messages,
#             response_format=EventWrapper,
#         )

#         parsed_events = completion.choices[0].message.parsed.events
#         print("Structured events parsed:", parsed_events)

#     except Exception as e:
#         print("GPT structured output failed:", e)
#         parsed_events = []

#     # Normalize for FullCalendar frontend
#     normalized = [{
#         "title": ev.title,
#         "start": ev.start,
#         "end": ev.end,
#         "location": ev.location,
#         "description": ev.description,
#         "backgroundColor": "#3788d8",
#         "calendarId": "primary",
#         "extendedProps": {
#             "location": ev.location,
#             "description": ev.description,
#             "creator": "",
#             "htmlLink": "",
#             "googleEventId": ""
#         }
#     } for ev in parsed_events]

#     # Update session
#     session = SessionStore(session_key=session_key)
#     session["event_suggestions"] = normalized
#     session["llm_processing"] = False

#     history = session.get("chat_history", [])
#     if history:
#         history[-1]["suggested_events"] = normalized
#     session["chat_history"] = history

#     session.save()
#     print("Events saved to session.")