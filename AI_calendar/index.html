<script>
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    document.addEventListener('DOMContentLoaded', function () {
            console.log("üí° DOM fully loaded. JS running.");
            const aiForm = document.getElementById('ai-query-form');
            console.log("üîç aiForm loaded:", aiForm);
            const aiResponseBox = document.getElementById('ai-response');
            if (!aiForm) {
            console.error("‚ùå aiForm not found in DOM.");
            return;
        }

        aiForm.addEventListener('submit', function (e) {
        console.log("üì¨ AI form submit triggered.");
        e.preventDefault();

        const query = document.getElementById('ai-input').value.trim();
        const fileInput = document.getElementById('ai-file').files[0];

        if (!query && !fileInput) {
            alert("Please provide a query or upload a file.");
            return;
        }

        const formData = new FormData();
        formData.append("query", query);
        if (fileInput) {
            formData.append("file", fileInput);
        }

        fetch('/ai-process-query/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                alert("‚ùå " + data.error);
                return;
            }

            // Update chat history
            fetch('/chat-history/')
                .then(res => res.json())
                .then(data => {
                    if (data.history) {
                        displayChatHistory(data.history);
                    }
                    console.log("üõ∞Ô∏è /chat-history/ returned:", data);
                });

            // ‚úÖ Start polling only if LLM is still processing
            if (data.processing) {
                console.log("üß™ Starting pollSuggestedEvents...");
                pollSuggestedEvents();
            }

            aiResponseBox.classList.remove('d-none');
            aiResponseBox.textContent = "‚úÖ Submitted. Waiting for AI to respond with events...";
            document.getElementById('ai-input').value = '';
            document.getElementById('ai-file').value = '';
        })
        .catch(err => {
            console.error("‚ùå Error submitting query:", err);
            alert("‚ùå Error submitting query.");
        });
    });


        const allEvents = [
            {% for event in events %}
            {
                title: "{{ event.summary|escapejs }}",
                start: "{{ event.start|escapejs }}",
                end: "{{ event.end|escapejs }}",
                backgroundColor: "{{ event.backgroundColor|default:'#3788d8' }}",
                calendarId: "{{ event.calendarId|escapejs }}",
                extendedProps: {
                    location: "{{ event.location|escapejs }}",
                    description: "{{ event.description|escapejs }}",
                    creator: "{{ event.creator|escapejs }}",
                    htmlLink: "{{ event.htmlLink|escapejs }}",
                    googleEventId: "{{ event.googleEventId|escapejs }}"
                }
            }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];

        const calendarEl = document.getElementById('calendar');
        const checkboxes = document.querySelectorAll('.calendar-toggle');
        let calendar = null;

        if (calendarEl) {
            calendar = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                height: 'auto',
                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,timeGridWeek,listWeek'
                },
                events: allEvents,

                eventClick: function (info) {
                    const props = info.event.extendedProps;
                    const title = info.event.title;
                    const start = info.event.start.toLocaleString();
                    const end = info.event.end ? info.event.end.toLocaleString() : 'N/A';
                    const location = props.location || 'N/A';
                    const description = props.description || 'N/A';
                    const creator = props.creator || 'N/A';
                    const htmlLink = props.htmlLink || '#';

                    const confirmDelete = confirm(
                        `Title: ${title}\nStart: ${start}\nEnd: ${end}\nLocation: ${location}\nDescription: ${description}\nCreator: ${creator}\n\nDo you want to delete this event?`
                    );

                    if (confirmDelete) {
                        fetch('/delete-event/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCookie('csrftoken')
                            },
                            body: JSON.stringify({
                                eventId: props.googleEventId,
                                calendarId: props.calendarId || "primary"
                            })
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (data.error) {
                                alert("‚ùå " + data.error);
                                return;
                            }

                        // Fetch updated session-based chat history from backend
                        fetch('/chat-history/')
                            .then(res => res.json())
                            .then(data => {
                                if (data.history) {
                                    displayChatHistory(data.history);
                                }
                            });
                            alert("‚úÖ Event deleted from Google Calendar.");

                        })
                        .catch(error => {
                            console.error("‚ùå Delete error:", error);
                            alert("‚ùå Error deleting event.");
                        });
                    }
                }
            });

            calendar.render();

            checkboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    const selectedCalendars = Array.from(checkboxes)
                        .filter(c => c.checked)
                        .map(c => c.value);
                    const filteredEvents = allEvents.filter(ev => selectedCalendars.includes(ev.calendarId));
                    calendar.removeAllEvents();
                    calendar.addEventSource(filteredEvents);
                });
            });
        }
        fetch('/chat-history/')
        .then(res => res.json())
        .then(data => {
            if (data.history) {
                displayChatHistory(data.history);
            }
        });
        fetch('/suggested-events/')
        .then(res => res.json())
        .then(data => {
            if (data.suggested_events) {
                displaySuggestedEvents(data.suggested_events);
            }
        });


        document.getElementById('add-event-toggle').addEventListener('click', function () {
            document.getElementById('manual-event-form').classList.toggle('d-none');
        });

        const manualForm = document.getElementById('manual-event-form');
        if (manualForm) {
            manualForm.addEventListener('submit', function (e) {
                e.preventDefault();

                function toRFC3339(localDateTime) {
                    const date = new Date(localDateTime);
                    return date.toISOString();
                }

                const title = document.getElementById('manual-title').value;
                const startRaw = document.getElementById('manual-start').value;
                const endRaw = document.getElementById('manual-end').value;
                const start = toRFC3339(startRaw);
                const end = toRFC3339(endRaw);
                const location = document.getElementById('manual-location').value;
                const description = document.getElementById('manual-description').value;

                if (new Date(start) >= new Date(end)) {
                    alert("‚ùå End time must be after start time.");
                    return;
                }

                const eventPayload = {
                    title,
                    start,
                    end,
                    location,
                    description
                };

                fetch('/add-event/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: new URLSearchParams(eventPayload)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        alert("‚úÖ Event added to Google Calendar!");

                        // Hide and reset the form
                        manualForm.classList.add('d-none');
                        manualForm.reset();

                        // Reload after short delay
                        setTimeout(() => {
                            location.reload();
                        }, 1000);  // wait 1 second
                    } else if (data.error) {
                        alert("‚ùå Failed: " + data.error);
                    }
                })
                .catch(error => {
                    console.error("‚ùå Network error adding event:", error);
                    alert("‚ùå Network error. Please try again.");
                });


            });
        }
    });

    function displayChatHistory(history) {
        console.log("üìú Rendering chat history:", history); 
        const container = document.getElementById("chat-history");
        container.innerHTML = ""; 

        history.forEach((entry, index) => {
            const card = document.createElement("div");
            card.className = "card mb-2 shadow-sm";
            card.innerHTML = `
                <div class="card-body">
                    <h6>Query ${index + 1}:</h6>
                    <p><strong>Input:</strong> ${entry.query || "<em>None</em>"}</p>
                    ${entry.file_text ? `<p><strong>PDF Preview:</strong><br><small>${entry.file_text.substring(0, 300)}...</small></p>` : ""}
                </div>
            `;
            container.appendChild(card);
        });
        }

    function displaySuggestedEvents(events) {
        console.log("displaySuggestedEvents called with:", events);
        const container = document.getElementById('event-suggestions');
        container.innerHTML = '';

        if (!events || events.length === 0) {
            container.innerHTML = "<p class='text-muted'>No event suggestions available.</p>";
            return;
        }

        events.forEach((event, idx) => {
            console.log("üìå Rendering event:", event);
            const div = document.createElement('div');
            div.className = "card mb-2 shadow-sm";

            const safe = (key, fallback = "") => event[key] || fallback;

            div.innerHTML = `
                <div class="card-body">
                    <h6>Suggested Event ${idx + 1}</h6>
                    <p><strong>Title:</strong> ${safe("title")}</p>
                    <p><strong>Start:</strong> ${safe("start")}</p>
                    <p><strong>End:</strong> ${safe("end")}</p>
                    <p><strong>Location:</strong> ${safe("location")}</p>
                    <p><strong>Description:</strong> ${safe("description")}</p>
                    <button class="btn btn-sm btn-success" onclick='submitSuggestedEvent(${JSON.stringify(JSON.stringify(event))})'>‚úÖ Submit</button>
                </div>
            `;
            container.appendChild(div);
        });
}

    function submitSuggestedEvent(eventStr) {
        const event = JSON.parse(eventStr);  // double parse due to JSON string escaping

        if (!event.title || !event.start || !event.end) {
            alert("‚ùå Missing required fields.");
            return;
        }

        fetch('/add-event/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: new URLSearchParams({
                title: event.title,
                start: event.start,
                end: event.end,
                location: event.location || '',
                description: event.description || ''
            })
        })
        .then(res => res.json())
        .then(data => {
            if (data.error) {
                alert("‚ùå " + data.error);
            } else {
                alert("‚úÖ Event submitted to Google Calendar!");
            }
        })
        .catch(err => {
            console.error("‚ùå Error submitting suggested event:", err);
            alert("‚ùå Submission failed.");
        });
    }

    function pollSuggestedEvents() {
        console.log("üîÅ pollSuggestedEvents() called");  

        const pollInterval = setInterval(() => {
            fetch('/poll-llm-status/')
                .then(res => res.json())
                .then(data => {
                    console.log("üì° Poll response:", data); 
                    if (!data.processing) {
                        clearInterval(pollInterval);
                        displaySuggestedEvents(data.suggested_events);
                        document.getElementById("ai-response").textContent = "‚úÖ New events received!";
                    } else {
                        console.log("‚åõ LLM still generating...");
                    }
                })
                .catch(err => {
                    console.error("‚ùå Polling error:", err);
                });
        }, 3000);
    }


</script>